program = _{ SOI ~ (fun | struct_def | enum_def)* ~ &EOI }

fun = { fn_kw ~ ident ~ params ~ (arw ~ ty)? ~ block }

params = { lp ~ (vardef ~ (cma ~ vardef)*)? ~ rp }

struct_def = { struct_kw ~ ident ~ lcb ~ (vardef ~ (cma ~ vardef)* ~ cma?)? ~ rcb }

enum_def = { enum_kw ~ ident ~ lcb ~ (variant_def ~ (cma ~ variant_def)* ~ cma?)? ~ rcb }

variant_def = { ident ~ (lp ~ ty ~ (cma ~ ty)* ~ rp)? }

block = { lcb ~ (!(expr ~ rcb) ~ stmt)* ~ expr? ~ rcb }

// Note: put expressions that can be used as statements without a ";"
// AFTER the (expr ~ sc) because of greediness
stmt = { return_stmt | break_stmt | continue_stmt | while_loop | for_loop | declare | assign | (expr ~ sc) | if_then | match_expr | block }

return_stmt = { return_kw ~ expr? ~ sc }

break_stmt = { break_kw ~ sc }

continue_stmt = { continue_kw ~ sc }

while_loop = { while_kw ~ expr ~ block }

for_loop = { for_kw ~ ident ~ in_kw ~ expr ~ block }

assign = { expr ~ eq ~ expr ~ sc }

declare = { var_kw ~ vardef ~ eq ~ expr ~ sc }

vardef = { ident ~ cln ~ ty }

expr = { if_then | match_expr | binop | with_postfix | primitive | block }

// Special parsing for matched expr that forbids struct instances (which would not be matchable in any case).
// Need to remove them now, because of parser greediness that causes some bugs with `match ident {}` which is parsed
// as being a match on the struct instance `ident {}`
matched_expr      = { if_then | match_expr | binop | matched_primitive | block }
matched_primitive = { primitive_wo_struct }

binop = { prefix* ~ (with_postfix | primitive) ~ (infix ~ prefix* ~ (with_postfix | primitive))* }

with_postfix = { primitive ~ (field_postfix | index_postfix | call_postfix | range_postfix)+ }

primitive           =  { struct_instance | primitive_wo_struct }
primitive_wo_struct = _{ array | unit | integer | boolean | string | namespaced | subexpr | ident }

subexpr = { lp ~ expr ~ rp }

namespaced = { ident ~ (clncln ~ ident)+ }

field_postfix = { dt ~ ident }

index_postfix = { lb ~ primitive ~ rb }

call_postfix = { lp ~ (expr ~ (cma ~ expr)*)? ~ rp }

range_postfix = { rg ~ expr }

struct_instance = { ident ~ lcb ~ (ident ~ cln ~ expr ~ cma)* ~ rcb }

integer = @{ '0'..'9' ~ ('0'..'9' | "_")* }

boolean = @{ "true" | "false" }

string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

ty = { iter_ty | array_ty | int_ty | str_ty | bool_ty | unit | ident }

// Separate iter_ty from others because it is left recursive
iter_ty = { non_iter_ty ~ rg+ }

non_iter_ty = { array_ty | int_ty | str_ty | bool_ty | unit | ident }

array_ty = { lb ~ ty ~ rb }

bool_ty = { "bool" }

str_ty = { "str" }

int_ty = { "int" }

keyword = { var_kw | struct_kw | if_kw | else_kw | while_kw | for_kw | in_kw | bool_ty | str_ty | int_ty | fn_kw | match_kw | break_kw | return_kw | continue_kw }

prefix = { bang | as_mut }
infix  = { add | sub | mul | div | rem | pow | le | lt | ge | gt | eqq | neq | and | or | not_in }

// second case is a hack to also match identifiers that start with a keyword
// https://stackoverflow.com/questions/61619285/peg-grammar-to-parse-identifier-name-which-is-not-a-keyword
ident = @{ !"__" ~ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* | keyword ~ (ASCII_ALPHANUMERIC | "_")+ }

if_then = { if_kw ~ expr ~ block ~ (else_kw ~ if_kw ~ expr ~ block)* ~ (else_kw ~ block)? }

match_expr = { match_kw ~ matched_expr ~ match_block }

match_block = { lcb ~ (pipe? ~ expr ~ farw ~ expr ~ (pipe ~ expr ~ farw ~ expr)*)? ~ rcb }

array = { lb ~ (expr ~ (cma ~ expr)*)? ~ rb }

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }

COMMENT = _{ ("//" ~ (!"\n" ~ ANY)* ~ "\n") | ("/*" ~ (!"*/" ~ ANY)* ~ "*/") }

// TOKENS
lcb = { "{" }
rcb = { "}" }
lp  = { "(" }
rp  = { ")" }
lb  = { "[" }
rb  = { "]" }

sc     = { ";" }
eq     = { "=" }
cln    = { ":" }
cma    = { "," }
dt     = { "." }
clncln = { "::" }
arw    = { "->" }
farw   = { "=>" }
pipe   = { "|" }

add = { "+" }
sub = { "-" }
mul = { "*" }
div = { "/" }
rem = { "%" }
pow = { "^" }
le  = { "<=" }
lt  = { "<" }
ge  = { ">=" }
gt  = { ">" }
eqq = { "==" }
neq = { "!=" }
and = { "&&" }
or  = { "||" }

bang   = { "!" }
not_in = { "not in" }
not    = { "not" }
as_mut = { "@" }

while_kw    = { "while" }
for_kw      = { "for" }
in_kw       = { "in" }
if_kw       = { "if" }
else_kw     = { "else" }
match_kw    = { "match" }
var_kw      = { "var" }
struct_kw   = { "struct" }
enum_kw     = { "enum" }
rg          = { ".." }
fn_kw       = { "fn" }
return_kw   = { "return" }
break_kw    = { "break" }
continue_kw = { "continue" }

unit = { "()" }
